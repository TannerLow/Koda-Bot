from datetime import datetime, timedelta
from typing import Optional
import os

import discord
from discord import Message
from dotenv import load_dotenv

from ..Logging.logger import Logger
from ..API.koda import Koda
from ..API.model import (
    Stats,
    User,
    Checkin
)
from ..API.exceptions import LackOfContributionError


load_dotenv()
ADMIN_ID = int(os.environ.get('ADMIN_ID'))

LOGGER = Logger(__file__, "debug")


class CommandParser:

    def __init__(self, command_prefix: str, koda_api: Koda):
        self.prefix = command_prefix
        self.actions = {
            "?": self.help,
            "stats": self.get_stats,
            "checkin": self.checkin,
            "register": self.register,
            "savedb": self.save_db,

            # UNIMPLEMENTED
            "clear": self.clear_user,
        }
        self.api = koda_api

    def is_command(self, message: str) -> bool:
        return (message[:len(self.prefix)+1] == self.prefix + ' ')
    
    async def parse_command(self, message: Message) -> None:
        command: str = message.content[len(self.prefix):].split()
        LOGGER.debug(f"Command after splitting: {command}")
        
        if len(command) < 1:
            LOGGER.debug("Command has no arguments")
            return

        action: str = command[0]
        if action in self.actions:
            LOGGER.debug(f"Action detected: {action}")
            await self.actions[action](message, command)
        
        else:
            LOGGER.debug("Command not recognized")

    async def help(self, message: Message, command: list[str]) -> None:
        LOGGER.debug("It's a help command")
        response_message:str = self.api.get_help_text()
        dm_channel = await message.author.create_dm()
        await dm_channel.send(response_message)

    async def get_stats(self, message: Message, command: list[str]) -> None:
        LOGGER.debug("It's a stats command")

        self._handle_new_user_case(message)

        stats: Stats = self.api.get_stats(str(message.author.id))

        # Discord embed makes a nice box around the content
        embed = discord.Embed(
            title=message.author.display_name,
            description="📊 Stats",
            color=discord.Color.red()  # You can set any color
        )

        # Add some fields (name, value, inline True/False)
        embed.add_field(
            name="Level",
            value=self._number_to_emoji(stats.level),
            inline=False
        )
        embed.add_field(
            name="XP",
            value=self._emoji_progress_bar(stats.xp, stats.total_xp_needed),
            inline=False
        )

        # Leaving comments as example for now
        # embed.add_field(name="⚔️ Attack", value="79 (1.8m)", inline=True)
        # embed.add_field(name="❤️ Hitpoints", value="76 (1.4m)", inline=True)
        # embed.add_field(name="🛡️ Defence", value="73 (999.8k)", inline=True)
        # embed.add_field(name="**Overall**", value="Level: 1653\nXP: 127,725,223", inline=False)
        # embed.set_footer(text="Generated by your bot")
        # embed.set_thumbnail(url="https://example.com/some_icon.png")  # Optional image in corner

        await message.channel.send(embed=embed)

    def _number_to_emoji(self, num: int) -> str:
        digit_map = {
            "0": "0️⃣",
            "1": "1️⃣",
            "2": "2️⃣",
            "3": "3️⃣",
            "4": "4️⃣",
            "5": "5️⃣",
            "6": "6️⃣",
            "7": "7️⃣",
            "8": "8️⃣",
            "9": "9️⃣",
        }
        return "".join(digit_map[d] for d in str(num))

    def _emoji_progress_bar(self, current: int, total: int, length: int = 10) -> str:
        if current < 0:
            current = 0
        if current > total:
            current = total
             
        filled = int(length * current // total)
        empty = length - filled
        return f"{'🟩' * filled}{'⬜' * empty} {current}/{total}"

    async def checkin(self, message: Message, command: list[str]) -> None:
        LOGGER.debug("It's a checkin command")

        expected_command_length: int = 2
        command_length: int = len(command)
        if command_length < expected_command_length:
            LOGGER.debug(f"Command not long enough: expected {expected_command_length}, received {command_length}")
            await message.channel.send("I don't understand. Say `koda ?` for help.")
            return

        self._handle_new_user_case(message)

        checkin: Checkin = Checkin(
            user_id=str(message.author.id),
            date=datetime.now(),
            proof=command[1]
        )

        try:
            remaining_cooldown: Optional[timedelta] = self.api.checkin(str(message.author.id), checkin)
            if remaining_cooldown:
                cooldown_str: str = self._format_timedelta(remaining_cooldown)
                await message.channel.send(f"You already checked in today. Cooldown: {cooldown_str}")
            else:
                xp_reward: int = 500
                self.api.give_xp(str(message.author.id), xp_reward)
                await message.channel.send(f"Check in confirmed :star: +{xp_reward} xp")
        
        except LackOfContributionError:
            await message.channel.send(f"You haven't contributed since your last checkin :face_with_raised_eyebrow:")

    def _format_timedelta(self, td: timedelta) -> str:
        total_seconds = int(td.total_seconds())
        if total_seconds < 0:
            raise ValueError("timedelta must be positive")

        days, remainder = divmod(total_seconds, 86400)  # 24*60*60
        hours, remainder = divmod(remainder, 3600)
        minutes, seconds = divmod(remainder, 60)

        parts = []
        if days: parts.append(f"{days}d")
        if hours: parts.append(f"{hours}h")
        if minutes: parts.append(f"{minutes}m")
        if seconds: parts.append(f"{seconds}s")

        return " ".join(parts) if parts else "0s"

    async def register(self, message: Message, command: list[str]) -> None:
        LOGGER.debug("It's a register command")
        
        expected_command_length: int = 2
        command_length: int = len(command)
        if command_length < expected_command_length:
            LOGGER.debug(f"Command not long enough: expected {expected_command_length}, received {command_length}")
            await message.channel.send("I don't understand. Say `koda ?` for help.")
            return
        
        self._handle_new_user_case(message)

        self.api.register_github_name(str(message.author.id), command[1])
        await message.channel.send(f"I registered your GitHub username as {command[1]} :white_check_mark:")

    async def clear_user(self, message: Message, command: list[str]) -> None:
        LOGGER.debug("It's a clear command")
        raise NotImplementedError("UNIMPLEMENTED COMMAND")
    
    def _handle_new_user_case(self, message: Message) -> None:
        if self.api.new_user_detected(str(message.author.id)):
            author: discord.User = message.author
            user: User = User(
                id=str(author.id)
            )
            self.api.establish_new_user(user)
            LOGGER.info(f"New user established: {user.model_dump_json()}")

    async def save_db(self, message: Message, command: list[str]) -> None:
        if message.author.id == ADMIN_ID:
            LOGGER.warn("[ADMIN] save db command issued by admin")
            self.api.save_db()
            await message.channel.send("Database has been saved :white_check_mark:")

        else:
            LOGGER.warn("[BREACH] save db command issued by non-admin")
    